{
  "id": "clarity-intro",
  "title": "Introduction to Clarity",
  "summary": "A decidable smart contract language designed for security.",
  "category": "Clarity Smart Contracts",
  "type": "article",
  "sourceId": "clarity-intro",
  "content": "# Introduction to Clarity\n\nClarity is a smart contract language designed for the Stacks blockchain with security and predictability as top priorities.\n\n## What Makes Clarity Different?\n\n### 1. Decidable\nUnlike Solidity or other Turing-complete languages, Clarity is **decidable**. This means you can know exactly what a program will do before executing it.\n\n**Benefits:**\n- No unexpected behavior\n- Complete static analysis possible\n- Easier auditing and verification\n\n### 2. Interpreted, Not Compiled\nClarity code is not compiled to bytecode. The code you write is the code that executes, making it:\n- Transparent\n- Verifiable on-chain\n- Free from compiler bugs\n\n### 3. No Reentrancy\nClarity's design prevents reentrancy attacks (like the DAO hack) by default.\n\n## Core Syntax\n\n### Defining Constants\n```clarity\n(define-constant contract-owner tx-sender)\n(define-constant err-owner-only (err u100))\n```\n\n### Data Variables\n```clarity\n(define-data-var counter uint u0)\n\n(define-public (increment)\n  (ok (var-set counter (+ (var-get counter) u1))))\n```\n\n### Public Functions\n```clarity\n(define-public (transfer (amount uint) (recipient principal))\n  (begin\n    (asserts! (>= (stx-get-balance tx-sender) amount) (err u1))\n    (try! (stx-transfer? amount tx-sender recipient))\n    (ok true)))\n```\n\n### Read-Only Functions\n```clarity\n(define-read-only (get-balance (account principal))\n  (stx-get-balance account))\n```\n\n## Data Structures\n\n### Maps (Key-Value Storage)\n```clarity\n(define-map balances principal uint)\n\n(map-set balances tx-sender u1000)\n(map-get? balances tx-sender)\n```\n\n### Fungible Tokens\n```clarity\n(define-fungible-token my-token)\n```\n\n### Non-Fungible Tokens\n```clarity\n(define-non-fungible-token my-nft uint)\n```\n\n## Safety Features\n\n1. **No Null/Undefined**: Uses optionals and results explicitly\n2. **Access Control**: Built-in checks like tx-sender\n3. **Math Safety**: Overflow protection built-in\n4. **Type Safety**: Strong static typing\n\n## Development Workflow\n\n1. **Write**: Create .clar files locally\n2. **Test**: Use Clarinet for local testing\n3. **Deploy**: Deploy to testnet/mainnet\n4. **Interact**: Call functions from web apps or CLI\n\n## Learning Resources\n\n- **Clarinet**: Local development environment\n- **Clarity Book**: Official documentation\n- **Hiro Platform**: APIs and tools\n- **Examples**: Study existing contracts on mainnet\n\nClarity's design philosophy prioritizes predictability and security over flexibility, making it ideal for financial applications and systems where correctness is critical."
}